#!/bin/bash
# Generate Java fixtures from Go fixture files
# This script reads test/go/*.go files and generates FixturesGen.java

set -e

cd "$(dirname "$0")"

OUTPUT="src/test/java/com/kriskowal/yay/FixturesGen.java"
TEST_ROOT="../test"
GO_DIR="$TEST_ROOT/go"
YAY_DIR="$TEST_ROOT/yay"

# Start the Java file
cat > "$OUTPUT" << 'HEADER'
// Code generated by gen_fixtures.sh; DO NOT EDIT.

package com.kriskowal.yay;

import java.math.BigInteger;
import java.util.*;

/**
 * Generated fixture data for testing.
 */
public class FixturesGen {
    
    // Helper methods
    private static List<Object> list(Object... items) {
        return Arrays.asList(items);
    }
    
    private static Map<String, Object> map(Object... kvs) {
        Map<String, Object> m = new LinkedHashMap<>();
        for (int i = 0; i + 1 < kvs.length; i += 2) {
            m.put((String) kvs[i], kvs[i + 1]);
        }
        return m;
    }
    
    private static byte[] bytes(int... values) {
        byte[] b = new byte[values.length];
        for (int i = 0; i < values.length; i++) {
            b[i] = (byte) values[i];
        }
        return b;
    }
    
    private static BigInteger bi(long value) {
        return BigInteger.valueOf(value);
    }
    
    public static final Map<String, Object> FIXTURES;
    
    static {
        FIXTURES = new LinkedHashMap<>();
HEADER

# Process each .go file that has a matching .yay file
for gofile in "$GO_DIR"/*.go; do
    if [ ! -f "$gofile" ]; then
        continue
    fi
    
    basename=$(basename "$gofile" .go)
    yayfile="$YAY_DIR/$basename.yay"
    
    if [ ! -f "$yayfile" ]; then
        continue
    fi
    
    # Read the Go expression
    expr=$(cat "$gofile")
    
    # Convert Go expression to Java using perl for better regex support
    java_expr=$(echo "$expr" | perl -pe '
        # Handle nil -> null first (word boundary)
        s/\bnil\b/null/g;
        
        # Handle math functions
        s/math\.NaN\(\)/Double.NaN/g;
        s/math\.Inf\(1\)/Double.POSITIVE_INFINITY/g;
        s/math\.Inf\(-1\)/Double.NEGATIVE_INFINITY/g;
        s/math\.Copysign\(0, -1\)/-0.0/g;
        
        # Convert big.NewInt(x) and NewInt(x) to bi(x)
        s/big\.NewInt\(([^)]*)\)/bi($1)/g;
        s/\bNewInt\(([^)]*)\)/bi($1)/g;
        
        # Convert Go helper functions List() and Map() to lowercase
        s/\bList\(/list(/g;
        s/\bMap\(/map(/g;
        
        # Convert map[string]any{} to map()
        s/map\[string\]any\{\}/map()/g;
        
        # Convert []any{} to list()
        s/\[\]any\{\}/list()/g;
        
        # Convert []byte{} to bytes()
        s/\[\]byte\{\}/bytes()/g;
        
        # Convert map[string]any{ to map(
        s/map\[string\]any\{/map(/g;
        
        # Convert []any{ to list(
        s/\[\]any\{/list(/g;
        
        # Convert []byte{ to bytes(
        s/\[\]byte\{/bytes(/g;
        
        # Convert closing } to )
        s/\}/)/g;
        
        # Convert "key": value to "key", value (inside map calls)
        # This is tricky - we need to convert : to , after string keys
        s/("(?:[^"\\]|\\.)*")\s*:\s*/$1, /g;
        
        # Handle \x08 -> \b and \x0c -> \f
        s/\\x08/\\b/g;
        s/\\x0c/\\f/g;
    ' | tr -d '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    
    echo "        FIXTURES.put(\"$basename\", $java_expr);"
done >> "$OUTPUT"

# Close the static block and class
cat >> "$OUTPUT" << 'FOOTER'
    }
}
FOOTER

echo "Generated $OUTPUT with fixtures"
