#!/usr/bin/env python3
"""
Generate C test fixtures header from fixture files.

This script reads:
- test/c/*.c files (C expressions using yay_* API) with matching test/yay/*.yay files
- test/nay/*.nay files (invalid YAY) with matching test/nay/*.error files
"""

from pathlib import Path


def escape_c_string(s):
    """Escape a string for use in a C string literal."""
    result = []
    for c in s:
        if c == '\\':
            result.append('\\\\')
        elif c == '"':
            result.append('\\"')
        elif c == '\n':
            result.append('\\n')
        elif c == '\t':
            result.append('\\t')
        elif c == '\r':
            result.append('\\r')
        elif c == '\0':
            result.append('\\0')
        elif ord(c) < 0x20 or ord(c) == 0x7f:
            result.append(f'\\x{ord(c):02x}')
        elif 0x80 <= ord(c) <= 0x9f:
            # C1 controls - use hex escapes for the UTF-8 bytes
            for b in c.encode('utf-8'):
                result.append(f'\\x{b:02x}')
        else:
            result.append(c)
    return ''.join(result)


def process_valid_fixture(c_path, yay_path):
    """Process a valid fixture pair (.c + .yay) and return fixture info."""
    with open(c_path, 'r') as f:
        c_expr = f.read().strip()
    
    with open(yay_path, 'r') as f:
        yay_content = f.read()
    
    if not c_expr:
        return None
    
    name = c_path.stem.replace('-', '_')
    yay_escaped = escape_c_string(yay_content)
    
    return {
        'name': name,
        'yay_escaped': yay_escaped,
        'c_expr': c_expr,
    }


def escape_c_bytes(data):
    """Escape raw bytes for use in a C string literal.

    Uses octal escapes for non-printable bytes to avoid the C hex escape
    greedy parsing problem (\\x09 followed by digit '2' would be read as
    \\x092).
    """
    result = []
    for b in data:
        if b == ord('\\'):
            result.append('\\\\')
        elif b == ord('"'):
            result.append('\\"')
        elif b == ord('\n'):
            result.append('\\n')
        elif 0x20 <= b <= 0x7e:
            result.append(chr(b))
        else:
            # Use 3-digit octal to avoid greedy parsing
            result.append(f'\\{b:03o}')
    return ''.join(result)


def process_error_fixture(nay_path, error_path):
    """Process an error fixture pair (.nay + .error) and return fixture info."""
    with open(nay_path, 'rb') as f:
        nay_bytes = f.read()

    with open(error_path, 'r') as f:
        error_pattern = f.read().strip()

    name = nay_path.stem.replace('-', '_')
    original_name = nay_path.stem  # Keep original for filename in test
    nay_escaped = escape_c_bytes(nay_bytes)
    nay_len = len(nay_bytes)
    error_escaped = escape_c_string(error_pattern)

    return {
        'name': name,
        'original_name': original_name,
        'nay_escaped': nay_escaped,
        'nay_len': nay_len,
        'error_pattern': error_escaped,
    }


def main():
    script_dir = Path(__file__).parent
    test_root = script_dir.parent / 'test'
    c_dir = test_root / 'c'
    yay_dir = test_root / 'yay'
    nay_dir = test_root / 'nay'
    output_file = script_dir / 'fixtures_gen.h'
    
    valid_fixtures = []
    error_fixtures = []
    
    # Process all .c files that have matching .yay files
    for c_file in sorted(c_dir.glob('*.c')):
        yay_file = yay_dir / c_file.with_suffix('.yay').name
        if not yay_file.exists():
            print(f'SKIP: {c_file.name} (no .yay file)')
            continue
        
        try:
            fixture = process_valid_fixture(c_file, yay_file)
            if fixture:
                valid_fixtures.append(fixture)
                print(f'OK: {c_file.name}')
            else:
                print(f'SKIP: {c_file.name} (empty)')
        except Exception as e:
            print(f'ERROR: {c_file.name}: {e}')
    
    # Process all .nay files that have matching .error files
    for nay_file in sorted(nay_dir.glob('*.nay')):
        error_file = nay_dir / nay_file.with_suffix('.error').name
        if not error_file.exists():
            print(f'SKIP: {nay_file.name} (no .error file)')
            continue
        
        try:
            fixture = process_error_fixture(nay_file, error_file)
            if fixture:
                error_fixtures.append(fixture)
                print(f'OK: {nay_file.name}')
            else:
                print(f'SKIP: {nay_file.name} (empty)')
        except Exception as e:
            print(f'ERROR: {nay_file.name}: {e}')
    
    # Generate C header
    with open(output_file, 'w') as f:
        f.write('/*\n')
        f.write(' * Generated by gen_fixtures.py - DO NOT EDIT\n')
        f.write(' */\n\n')
        f.write('#ifndef FIXTURES_GEN_H\n')
        f.write('#define FIXTURES_GEN_H\n\n')
        f.write('#include "yay.h"\n')
        f.write('#include <math.h>\n\n')
        
        # Valid fixture type
        f.write('typedef struct {\n')
        f.write('    const char *name;\n')
        f.write('    const char *yay_source;\n')
        f.write('    yay_value_t *(*make_expected)(void);\n')
        f.write('} test_fixture_t;\n\n')
        
        # Error fixture type
        f.write('typedef struct {\n')
        f.write('    const char *name;\n')
        f.write('    const char *original_name;\n')
        f.write('    const char *nay_source;\n')
        f.write('    size_t nay_len;\n')
        f.write('    const char *error_pattern;\n')
        f.write('} error_fixture_t;\n\n')
        
        # Generate expected value functions for valid fixtures
        for fix in valid_fixtures:
            f.write(f'static yay_value_t *make_expected_{fix["name"]}(void) {{\n')
            f.write(f'    return {fix["c_expr"]};\n')
            f.write('}\n\n')
        
        # Generate valid fixture array
        f.write('static test_fixture_t test_fixtures[] = {\n')
        for fix in valid_fixtures:
            f.write(f'    {{"{fix["name"]}", "{fix["yay_escaped"]}", make_expected_{fix["name"]}}},\n')
        f.write('    {NULL, NULL, NULL}\n')
        f.write('};\n\n')
        
        f.write(f'#define TEST_FIXTURE_COUNT {len(valid_fixtures)}\n\n')
        
        # Generate error fixture array
        f.write('static error_fixture_t error_fixtures[] = {\n')
        for fix in error_fixtures:
            f.write(f'    {{"{fix["name"]}", "{fix["original_name"]}.nay", "{fix["nay_escaped"]}", {fix["nay_len"]}, "{fix["error_pattern"]}"}},\n')
        f.write('    {NULL, NULL, NULL, 0, NULL}\n')
        f.write('};\n\n')
        
        f.write(f'#define ERROR_FIXTURE_COUNT {len(error_fixtures)}\n\n')
        
        f.write('#endif /* FIXTURES_GEN_H */\n')
    
    print(f'\nGenerated {output_file} with {len(valid_fixtures)} valid fixtures and {len(error_fixtures)} error fixtures')


if __name__ == '__main__':
    main()
